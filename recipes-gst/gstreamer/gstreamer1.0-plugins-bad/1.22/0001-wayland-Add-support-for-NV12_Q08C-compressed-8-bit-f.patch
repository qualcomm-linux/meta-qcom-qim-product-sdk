From e536c680aa728e60ffd940dfe786aebe62ebccdb Mon Sep 17 00:00:00 2001
From: Tushar Patra Jamula <quic_tjamula@quicinc.com>
Date: Tue, 4 Feb 2025 17:11:27 +0530
Subject: [PATCH] wayland: Add support for NV12_Q08C (compressed 8-bit) format

Upstream-Status: Inappropriate [Qualcomm specific]

Signed-off-by: Tushar Patra Jamula <quic_tjamula@quicinc.com>
---
 ext/wayland/gstwaylandsink.c            | 11 +++-
 gst-libs/gst/wayland/gstwldisplay.c     | 37 ++++++++++-
 gst-libs/gst/wayland/gstwldisplay.h     |  3 +
 gst-libs/gst/wayland/gstwllinuxdmabuf.c | 16 +++--
 gst-libs/gst/wayland/gstwlvideoformat.c | 88 ++++++++++++++++---------
 gst-libs/gst/wayland/gstwlvideoformat.h |  9 ++-
 6 files changed, 123 insertions(+), 41 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 2f116bf..89d462a 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -70,7 +70,7 @@ GST_DEBUG_CATEGORY (gstwayland_debug);
 #define WL_VIDEO_FORMATS \
     "{ BGRx, BGRA, RGBx, xBGR, xRGB, RGBA, ABGR, ARGB, RGB, BGR, " \
     "RGB16, BGR16, YUY2, YVYU, UYVY, AYUV, NV12, NV21, NV16, NV61, " \
-    "YUV9, YVU9, Y41B, I420, YV12, Y42B, v308 }"
+    "YUV9, YVU9, Y41B, I420, YV12, Y42B, v308, NV12_Q08C }"
 
 static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
@@ -524,9 +524,11 @@ gst_wayland_sink_get_caps (GstBaseSink * bsink, GstCaps * filter)
     GValue shm_list = G_VALUE_INIT, dmabuf_list = G_VALUE_INIT;
     GValue value = G_VALUE_INIT;
     GArray *formats;
+    GArray *modifiers;
     gint i;
     guint fmt;
     GstVideoFormat gfmt;
+    guint64 modifier;
 
     g_value_init (&shm_list, GST_TYPE_LIST);
     g_value_init (&dmabuf_list, GST_TYPE_LIST);
@@ -548,9 +550,11 @@ gst_wayland_sink_get_caps (GstBaseSink * bsink, GstCaps * filter)
 
     /* Add corresponding dmabuf formats */
     formats = gst_wl_display_get_dmabuf_formats (self->display);
+    modifiers = gst_wl_display_get_dmabuf_modifiers (self->display);
     for (i = 0; i < formats->len; i++) {
       fmt = g_array_index (formats, uint32_t, i);
-      gfmt = gst_wl_dmabuf_format_to_video_format (fmt);
+      modifier = g_array_index (modifiers, uint64_t, i);
+      gfmt = gst_wl_dmabuf_format_with_modifier_to_video_format (fmt, modifier);
       if (gfmt != GST_VIDEO_FORMAT_UNKNOWN) {
         g_value_init (&value, G_TYPE_STRING);
         g_value_set_static_string (&value, gst_video_format_to_string (gfmt));
@@ -815,7 +819,8 @@ gst_wayland_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
     guint i, nb_dmabuf = 0;
 
     for (i = 0; i < gst_buffer_n_memory (buffer); i++)
-      if (gst_is_dmabuf_memory (gst_buffer_peek_memory (buffer, i)))
+      if (gst_is_dmabuf_memory (gst_buffer_peek_memory (buffer, i)) ||
+          gst_is_fd_memory (gst_buffer_peek_memory (buffer, i)))
         nb_dmabuf++;
 
     if (nb_dmabuf && (nb_dmabuf == gst_buffer_n_memory (buffer)))
diff --git a/gst-libs/gst/wayland/gstwldisplay.c b/gst-libs/gst/wayland/gstwldisplay.c
index 1f83cb2..02ed853 100644
--- a/gst-libs/gst/wayland/gstwldisplay.c
+++ b/gst-libs/gst/wayland/gstwldisplay.c
@@ -52,6 +52,7 @@ typedef struct _GstWlDisplayPrivate
   struct zwp_linux_dmabuf_v1 *dmabuf;
   GArray *shm_formats;
   GArray *dmabuf_formats;
+  GArray *dmabuf_modifiers;
 
   /* private */
   gboolean own_display;
@@ -85,6 +86,7 @@ gst_wl_display_init (GstWlDisplay * self)
 
   priv->shm_formats = g_array_new (FALSE, FALSE, sizeof (uint32_t));
   priv->dmabuf_formats = g_array_new (FALSE, FALSE, sizeof (uint32_t));
+  priv->dmabuf_modifiers = g_array_new (FALSE, FALSE, sizeof (uint64_t));
   priv->wl_fd_poll = gst_poll_new (TRUE);
   priv->buffers = g_hash_table_new (g_direct_hash, g_direct_equal);
   g_mutex_init (&priv->buffers_mutex);
@@ -123,6 +125,7 @@ gst_wl_display_finalize (GObject * gobject)
 
   g_array_unref (priv->shm_formats);
   g_array_unref (priv->dmabuf_formats);
+  g_array_unref (priv->dmabuf_modifiers);
   gst_poll_free (priv->wl_fd_poll);
   g_hash_table_unref (priv->buffers);
   g_mutex_clear (&priv->buffers_mutex);
@@ -181,16 +184,28 @@ static const struct wl_shm_listener shm_listener = {
 static void
 dmabuf_format (void *data, struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf,
     uint32_t format)
+{
+  /* Reading formats from modifiers callback */
+}
+
+static void
+dmabuf_modifiers (void *data, struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf,
+    uint32_t format, uint32_t modifier_hi, uint32_t modifier_lo)
 {
   GstWlDisplay *self = data;
   GstWlDisplayPrivate *priv = gst_wl_display_get_instance_private (self);
+  uint64_t modifier = ((uint64_t)modifier_hi << 32) | modifier_lo;
 
-  if (gst_wl_dmabuf_format_to_video_format (format) != GST_VIDEO_FORMAT_UNKNOWN)
+  if (gst_wl_dmabuf_format_with_modifier_to_video_format (format, modifier) !=
+    GST_VIDEO_FORMAT_UNKNOWN) {
     g_array_append_val (priv->dmabuf_formats, format);
+    g_array_append_val (priv->dmabuf_modifiers, modifier);
+  }
 }
 
 static const struct zwp_linux_dmabuf_v1_listener dmabuf_listener = {
   dmabuf_format,
+  dmabuf_modifiers,
 };
 
 gboolean
@@ -220,7 +235,9 @@ gst_wl_display_check_format_for_dmabuf (GstWlDisplay * self,
 {
   GstWlDisplayPrivate *priv = gst_wl_display_get_instance_private (self);
   GArray *formats;
+  GArray *modifiers;
   guint i, dmabuf_fmt;
+  guint64 dmabuf_modifier;
 
   if (!priv->dmabuf)
     return FALSE;
@@ -229,9 +246,15 @@ gst_wl_display_check_format_for_dmabuf (GstWlDisplay * self,
   if (dmabuf_fmt == (guint) - 1)
     return FALSE;
 
+  dmabuf_modifier = gst_video_format_to_wl_dmabuf_modifier (format);
+  if (dmabuf_modifier == G_MAXUINT64)
+    return FALSE;
+
   formats = priv->dmabuf_formats;
+  modifiers = priv->dmabuf_modifiers;
   for (i = 0; i < formats->len; i++) {
-    if (g_array_index (formats, uint32_t, i) == dmabuf_fmt)
+    if (g_array_index (formats, uint32_t, i) == dmabuf_fmt &&
+        g_array_index (modifiers, uint64_t, i) == dmabuf_modifier)
       return TRUE;
   }
 
@@ -277,7 +300,7 @@ registry_handle_global (void *data, struct wl_registry *registry,
         wl_registry_bind (registry, id, &wp_viewporter_interface, 1);
   } else if (g_strcmp0 (interface, "zwp_linux_dmabuf_v1") == 0) {
     priv->dmabuf =
-        wl_registry_bind (registry, id, &zwp_linux_dmabuf_v1_interface, 1);
+        wl_registry_bind (registry, id, &zwp_linux_dmabuf_v1_interface, 3);
     zwp_linux_dmabuf_v1_add_listener (priv->dmabuf, &dmabuf_listener, self);
   }
 }
@@ -558,6 +581,14 @@ gst_wl_display_get_dmabuf_formats (GstWlDisplay * self)
   return priv->dmabuf_formats;
 }
 
+GArray *
+gst_wl_display_get_dmabuf_modifiers (GstWlDisplay * self)
+{
+  GstWlDisplayPrivate *priv = gst_wl_display_get_instance_private (self);
+
+  return priv->dmabuf_modifiers;
+}
+
 gboolean
 gst_wl_display_has_own_display (GstWlDisplay * self)
 {
diff --git a/gst-libs/gst/wayland/gstwldisplay.h b/gst-libs/gst/wayland/gstwldisplay.h
index eb07e4f..82564dd 100644
--- a/gst-libs/gst/wayland/gstwldisplay.h
+++ b/gst-libs/gst/wayland/gstwldisplay.h
@@ -91,6 +91,9 @@ GArray *gst_wl_display_get_shm_formats (GstWlDisplay * self);
 GST_WL_API
 GArray *gst_wl_display_get_dmabuf_formats (GstWlDisplay * self);
 
+GST_WL_API
+GArray *gst_wl_display_get_dmabuf_modifiers (GstWlDisplay * self);
+
 GST_WL_API
 struct zwp_linux_dmabuf_v1 *gst_wl_display_get_dmabuf_v1 (GstWlDisplay * self);
 
diff --git a/gst-libs/gst/wayland/gstwllinuxdmabuf.c b/gst-libs/gst/wayland/gstwllinuxdmabuf.c
index d6ee6ec..0270f61 100644
--- a/gst-libs/gst/wayland/gstwllinuxdmabuf.c
+++ b/gst-libs/gst/wayland/gstwllinuxdmabuf.c
@@ -92,12 +92,14 @@ gst_wl_linux_dmabuf_construct_wl_buffer (GstBuffer * buf,
   struct zwp_linux_buffer_params_v1 *params;
   gint64 timeout;
   ConstructBufferData data;
+  guint64 modifier = 0;
 
   g_return_val_if_fail (gst_wl_display_check_format_for_dmabuf (display,
           GST_VIDEO_INFO_FORMAT (info)), NULL);
 
   mem = gst_buffer_peek_memory (buf, 0);
   format = gst_video_format_to_wl_dmabuf_format (GST_VIDEO_INFO_FORMAT (info));
+  modifier = gst_video_format_to_wl_dmabuf_modifier (GST_VIDEO_INFO_FORMAT (info));
 
   g_cond_init (&data.cond);
   g_mutex_init (&data.lock);
@@ -109,7 +111,7 @@ gst_wl_linux_dmabuf_construct_wl_buffer (GstBuffer * buf,
 
   GST_DEBUG_OBJECT (display, "Creating wl_buffer from DMABuf of size %"
       G_GSSIZE_FORMAT " (%d x %d), format %s", info->size, width, height,
-      gst_wl_dmabuf_format_to_string (format));
+      gst_wl_dmabuf_format_to_string (format, modifier));
 
   /* Creation and configuration of planes  */
   params = zwp_linux_dmabuf_v1_create_params (gst_wl_display_get_dmabuf_v1
@@ -123,9 +125,15 @@ gst_wl_linux_dmabuf_construct_wl_buffer (GstBuffer * buf,
     stride = GST_VIDEO_INFO_PLANE_STRIDE (info, i);
     if (gst_buffer_find_memory (buf, offset, 1, &mem_idx, &length, &skip)) {
       GstMemory *m = gst_buffer_peek_memory (buf, mem_idx);
-      gint fd = gst_dmabuf_memory_get_fd (m);
-      zwp_linux_buffer_params_v1_add (params, fd, i, m->offset + skip,
-          stride, 0, 0);
+      gint fd;
+
+      if (gst_is_dmabuf_memory (m))
+        fd = gst_dmabuf_memory_get_fd (m);
+      else
+        fd = gst_fd_memory_get_fd (m);
+
+      zwp_linux_buffer_params_v1_add (params, fd, i, m->offset + skip, stride,
+          modifier >> 32, modifier & 0xffffffff);
     } else {
       GST_ERROR_OBJECT (mem->allocator, "memory does not seem to contain "
           "enough data for the specified format");
diff --git a/gst-libs/gst/wayland/gstwlvideoformat.c b/gst-libs/gst/wayland/gstwlvideoformat.c
index 73455bd..d136a3f 100644
--- a/gst-libs/gst/wayland/gstwlvideoformat.c
+++ b/gst-libs/gst/wayland/gstwlvideoformat.c
@@ -49,38 +49,40 @@ typedef struct
 {
   enum wl_shm_format wl_shm_format;
   guint dma_format;
+  guint64 dma_modifier;
   GstVideoFormat gst_format;
 } wl_VideoFormat;
 
 static const wl_VideoFormat wl_formats[] = {
-  {WL_SHM_FORMAT_XRGB8888, DRM_FORMAT_XRGB8888, GST_VIDEO_FORMAT_BGRx},
-  {WL_SHM_FORMAT_ARGB8888, DRM_FORMAT_ARGB8888, GST_VIDEO_FORMAT_BGRA},
-  {WL_SHM_FORMAT_XBGR8888, DRM_FORMAT_XBGR8888, GST_VIDEO_FORMAT_RGBx},
-  {WL_SHM_FORMAT_RGBX8888, DRM_FORMAT_RGBX8888, GST_VIDEO_FORMAT_xBGR},
-  {WL_SHM_FORMAT_BGRX8888, DRM_FORMAT_BGRX8888, GST_VIDEO_FORMAT_xRGB},
-  {WL_SHM_FORMAT_ABGR8888, DRM_FORMAT_ABGR8888, GST_VIDEO_FORMAT_RGBA},
-  {WL_SHM_FORMAT_RGBA8888, DRM_FORMAT_RGBA8888, GST_VIDEO_FORMAT_ABGR},
-  {WL_SHM_FORMAT_BGRA8888, DRM_FORMAT_BGRA8888, GST_VIDEO_FORMAT_ARGB},
-  {WL_SHM_FORMAT_RGB888, DRM_FORMAT_RGB888, GST_VIDEO_FORMAT_BGR},
-  {WL_SHM_FORMAT_BGR888, DRM_FORMAT_BGR888, GST_VIDEO_FORMAT_RGB},
-  {WL_SHM_FORMAT_RGB565, DRM_FORMAT_RGB565, GST_VIDEO_FORMAT_RGB16},
-  {WL_SHM_FORMAT_BGR565, DRM_FORMAT_BGR565, GST_VIDEO_FORMAT_BGR16},
-
-  {WL_SHM_FORMAT_YUYV, DRM_FORMAT_YUYV, GST_VIDEO_FORMAT_YUY2},
-  {WL_SHM_FORMAT_YVYU, DRM_FORMAT_YVYU, GST_VIDEO_FORMAT_YVYU},
-  {WL_SHM_FORMAT_UYVY, DRM_FORMAT_UYVY, GST_VIDEO_FORMAT_UYVY},
-  {WL_SHM_FORMAT_AYUV, DRM_FORMAT_AYUV, GST_VIDEO_FORMAT_AYUV},
-  {WL_SHM_FORMAT_NV12, DRM_FORMAT_NV12, GST_VIDEO_FORMAT_NV12},
-  {WL_SHM_FORMAT_NV21, DRM_FORMAT_NV21, GST_VIDEO_FORMAT_NV21},
-  {WL_SHM_FORMAT_NV16, DRM_FORMAT_NV16, GST_VIDEO_FORMAT_NV16},
-  {WL_SHM_FORMAT_NV61, DRM_FORMAT_NV61, GST_VIDEO_FORMAT_NV61},
-  {WL_SHM_FORMAT_YUV410, DRM_FORMAT_YUV410, GST_VIDEO_FORMAT_YUV9},
-  {WL_SHM_FORMAT_YVU410, DRM_FORMAT_YVU410, GST_VIDEO_FORMAT_YVU9},
-  {WL_SHM_FORMAT_YUV411, DRM_FORMAT_YUV411, GST_VIDEO_FORMAT_Y41B},
-  {WL_SHM_FORMAT_YUV420, DRM_FORMAT_YUV420, GST_VIDEO_FORMAT_I420},
-  {WL_SHM_FORMAT_YVU420, DRM_FORMAT_YVU420, GST_VIDEO_FORMAT_YV12},
-  {WL_SHM_FORMAT_YUV422, DRM_FORMAT_YUV422, GST_VIDEO_FORMAT_Y42B},
-  {WL_SHM_FORMAT_YUV444, DRM_FORMAT_YUV444, GST_VIDEO_FORMAT_v308},
+  {WL_SHM_FORMAT_XRGB8888, DRM_FORMAT_XRGB8888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_BGRx},
+  {WL_SHM_FORMAT_ARGB8888, DRM_FORMAT_ARGB8888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_BGRA},
+  {WL_SHM_FORMAT_XBGR8888, DRM_FORMAT_XBGR8888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_RGBx},
+  {WL_SHM_FORMAT_RGBX8888, DRM_FORMAT_RGBX8888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_xBGR},
+  {WL_SHM_FORMAT_BGRX8888, DRM_FORMAT_BGRX8888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_xRGB},
+  {WL_SHM_FORMAT_ABGR8888, DRM_FORMAT_ABGR8888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_RGBA},
+  {WL_SHM_FORMAT_RGBA8888, DRM_FORMAT_RGBA8888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_ABGR},
+  {WL_SHM_FORMAT_BGRA8888, DRM_FORMAT_BGRA8888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_ARGB},
+  {WL_SHM_FORMAT_RGB888, DRM_FORMAT_RGB888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_BGR},
+  {WL_SHM_FORMAT_BGR888, DRM_FORMAT_BGR888, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_RGB},
+  {WL_SHM_FORMAT_RGB565, DRM_FORMAT_RGB565, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_RGB16},
+  {WL_SHM_FORMAT_BGR565, DRM_FORMAT_BGR565, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_BGR16},
+
+  {WL_SHM_FORMAT_YUYV, DRM_FORMAT_YUYV, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_YUY2},
+  {WL_SHM_FORMAT_YVYU, DRM_FORMAT_YVYU, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_YVYU},
+  {WL_SHM_FORMAT_UYVY, DRM_FORMAT_UYVY, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_UYVY},
+  {WL_SHM_FORMAT_AYUV, DRM_FORMAT_AYUV, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_AYUV},
+  {WL_SHM_FORMAT_NV12, DRM_FORMAT_NV12, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_NV12},
+  {WL_SHM_FORMAT_NV21, DRM_FORMAT_NV21, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_NV21},
+  {WL_SHM_FORMAT_NV16, DRM_FORMAT_NV16, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_NV16},
+  {WL_SHM_FORMAT_NV61, DRM_FORMAT_NV61, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_NV61},
+  {WL_SHM_FORMAT_YUV410, DRM_FORMAT_YUV410, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_YUV9},
+  {WL_SHM_FORMAT_YVU410, DRM_FORMAT_YVU410, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_YVU9},
+  {WL_SHM_FORMAT_YUV411, DRM_FORMAT_YUV411, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_Y41B},
+  {WL_SHM_FORMAT_YUV420, DRM_FORMAT_YUV420, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_I420},
+  {WL_SHM_FORMAT_YVU420, DRM_FORMAT_YVU420, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_YV12},
+  {WL_SHM_FORMAT_YUV422, DRM_FORMAT_YUV422, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_Y42B},
+  {WL_SHM_FORMAT_YUV444, DRM_FORMAT_YUV444, DRM_FORMAT_MOD_LINEAR, GST_VIDEO_FORMAT_v308},
+  {WL_SHM_FORMAT_NV12, DRM_FORMAT_NV12, DRM_FORMAT_MOD_QCOM_COMPRESSED, GST_VIDEO_FORMAT_NV12_Q08C},
 };
 
 enum wl_shm_format
@@ -109,6 +111,19 @@ gst_video_format_to_wl_dmabuf_format (GstVideoFormat format)
   return -1;
 }
 
+guint64
+gst_video_format_to_wl_dmabuf_modifier (GstVideoFormat format)
+{
+  guint i;
+
+  for (i = 0; i < G_N_ELEMENTS (wl_formats); i++)
+    if (wl_formats[i].gst_format == format)
+      return wl_formats[i].dma_modifier;
+
+  GST_WARNING ("wayland dmabuf modifier not found");
+  return G_MAXUINT64;
+}
+
 GstVideoFormat
 gst_wl_shm_format_to_video_format (enum wl_shm_format wl_format)
 {
@@ -133,6 +148,19 @@ gst_wl_dmabuf_format_to_video_format (guint wl_format)
   return GST_VIDEO_FORMAT_UNKNOWN;
 }
 
+GstVideoFormat
+gst_wl_dmabuf_format_with_modifier_to_video_format (guint wl_format, guint64 modifier)
+{
+  guint i;
+
+  for (i = 0; i < G_N_ELEMENTS (wl_formats); i++)
+    if (wl_formats[i].dma_format == wl_format &&
+        wl_formats[i].dma_modifier == modifier)
+      return wl_formats[i].gst_format;
+
+  return GST_VIDEO_FORMAT_UNKNOWN;
+}
+
 const gchar *
 gst_wl_shm_format_to_string (enum wl_shm_format wl_format)
 {
@@ -141,8 +169,8 @@ gst_wl_shm_format_to_string (enum wl_shm_format wl_format)
 }
 
 const gchar *
-gst_wl_dmabuf_format_to_string (guint wl_format)
+gst_wl_dmabuf_format_to_string (guint wl_format, guint64 modifier)
 {
   return gst_video_format_to_string
-      (gst_wl_dmabuf_format_to_video_format (wl_format));
+      (gst_wl_dmabuf_format_with_modifier_to_video_format (wl_format, modifier));
 }
diff --git a/gst-libs/gst/wayland/gstwlvideoformat.h b/gst-libs/gst/wayland/gstwlvideoformat.h
index bc36a08..86ad1a2 100644
--- a/gst-libs/gst/wayland/gstwlvideoformat.h
+++ b/gst-libs/gst/wayland/gstwlvideoformat.h
@@ -38,16 +38,23 @@ enum wl_shm_format gst_video_format_to_wl_shm_format (GstVideoFormat format);
 GST_WL_API
 gint gst_video_format_to_wl_dmabuf_format (GstVideoFormat format);
 
+GST_WL_API
+guint64 gst_video_format_to_wl_dmabuf_modifier (GstVideoFormat format);
+
 GST_WL_API
 GstVideoFormat gst_wl_shm_format_to_video_format (enum wl_shm_format wl_format);
 
 GST_WL_API
 GstVideoFormat gst_wl_dmabuf_format_to_video_format (guint wl_format);
 
+GST_WL_API
+GstVideoFormat gst_wl_dmabuf_format_with_modifier_to_video_format (
+    guint wl_format, guint64 modifier);
+
 GST_WL_API
 const gchar *gst_wl_shm_format_to_string (enum wl_shm_format wl_format);
 
 GST_WL_API
-const gchar *gst_wl_dmabuf_format_to_string (guint wl_format);
+const gchar *gst_wl_dmabuf_format_to_string (guint wl_format, guint64 modifier);
 
 G_END_DECLS
